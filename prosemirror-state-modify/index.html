<!DOCTYPE html>
<html lang=en>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5" />
    <meta name="description" content="上一篇文章上讲到了prosemirror是如何把state的状态渲染到DOM视图的，这一篇文章来分析一下用户的编辑操作是怎么去修改state的。 一、prosemirror-stateprosemirror-state是propsemirror用于描述整篇文档状态的数据结构，它主要包括以下几个属性； docdoc就是当前整篇文档的数据内容，doc是一个Node类型元素，Node可以理解为prose">
<meta property="og:type" content="article">
<meta property="og:title" content="富文本编辑框架Prosemirror - 如何对state进行修改">
<meta property="og:url" content="http://lastnigtic.cn/prosemirror-state-modify/index.html">
<meta property="og:site_name" content="Blog of lastnigtic">
<meta property="og:description" content="上一篇文章上讲到了prosemirror是如何把state的状态渲染到DOM视图的，这一篇文章来分析一下用户的编辑操作是怎么去修改state的。 一、prosemirror-stateprosemirror-state是propsemirror用于描述整篇文档状态的数据结构，它主要包括以下几个属性； docdoc就是当前整篇文档的数据内容，doc是一个Node类型元素，Node可以理解为prose">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://lastnigtic.cn/.cn//list-dom.png">
<meta property="og:image" content="http://lastnigtic.cn/.cn//slice.png">
<meta property="og:image" content="http://lastnigtic.cn/.cn//target-depths.png">
<meta property="article:published_time" content="2020-09-05T16:00:00.000Z">
<meta property="article:modified_time" content="2021-06-27T14:33:20.579Z">
<meta property="article:author" content="lastnigtic">
<meta property="article:tag" content="lastnigtic">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://lastnigtic.cn/.cn//list-dom.png">
    
    
      
        
          <link rel="shortcut icon" href="/images/favicon.ico">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
        
      
    
    <!-- title -->
    <title>富文本编辑框架Prosemirror - 如何对state进行修改</title>
    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
    <!-- rss -->
    
    
	<!-- mathjax -->
	
<meta name="generator" content="Hexo 5.4.0"></head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#" aria-label="Menu"><i class="fas fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#" aria-label="Menu"><i class="fas fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" "Top" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fas fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/archives/">Writing</a></li>
        
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" aria-label="Previous post " href="/prosemirror-state-to-dom/"><i class="fas fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" aria-label="Next post " href="/prosemirror-first/"><i class="fas fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" aria-label="Back to top " href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" aria-label="Share post " href="#"><i class="fas fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=http://lastnigtic.cn/prosemirror-state-modify/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=http://lastnigtic.cn/prosemirror-state-modify/&text=富文本编辑框架Prosemirror - 如何对state进行修改"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=http://lastnigtic.cn/prosemirror-state-modify/&title=富文本编辑框架Prosemirror - 如何对state进行修改"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=http://lastnigtic.cn/prosemirror-state-modify/&is_video=false&description=富文本编辑框架Prosemirror - 如何对state进行修改"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=富文本编辑框架Prosemirror - 如何对state进行修改&body=Check out this article: http://lastnigtic.cn/prosemirror-state-modify/"><i class="fas fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=http://lastnigtic.cn/prosemirror-state-modify/&title=富文本编辑框架Prosemirror - 如何对state进行修改"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=http://lastnigtic.cn/prosemirror-state-modify/&title=富文本编辑框架Prosemirror - 如何对state进行修改"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=http://lastnigtic.cn/prosemirror-state-modify/&title=富文本编辑框架Prosemirror - 如何对state进行修改"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=http://lastnigtic.cn/prosemirror-state-modify/&title=富文本编辑框架Prosemirror - 如何对state进行修改"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=http://lastnigtic.cn/prosemirror-state-modify/&name=富文本编辑框架Prosemirror - 如何对state进行修改&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=http://lastnigtic.cn/prosemirror-state-modify/&t=富文本编辑框架Prosemirror - 如何对state进行修改"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81prosemirror-state"><span class="toc-number">1.</span> <span class="toc-text">一、prosemirror-state</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#doc"><span class="toc-number">1.1.</span> <span class="toc-text">doc</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#selection"><span class="toc-number">1.2.</span> <span class="toc-text">selection</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tr-Transaction"><span class="toc-number">1.3.</span> <span class="toc-text">tr(Transaction)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Schema"><span class="toc-number">1.4.</span> <span class="toc-text">Schema</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81State%E6%9B%B4%E6%96%B0%E8%BF%87%E7%A8%8B"><span class="toc-number">2.</span> <span class="toc-text">二、State更新过程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E8%8B%B1%E6%96%87"><span class="toc-number">2.1.</span> <span class="toc-text">输入英文</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E4%B8%AD%E6%96%87"><span class="toc-number">2.2.</span> <span class="toc-text">输入中文</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AF%BB%E6%89%BE%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE"><span class="toc-number">2.3.</span> <span class="toc-text">如何寻找插入位置</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A6%96%E5%85%88%E4%BB%8E%E4%B8%80%E4%B8%AA%E4%B8%89%E7%BA%A7%E5%B5%8C%E5%A5%97%E7%9A%84%E5%88%97%E8%A1%A8%E8%8A%82%E7%82%B9%E5%A4%8D%E5%88%B6%E5%87%BA%E5%86%85%E5%AE%B9"><span class="toc-number">2.3.1.</span> <span class="toc-text">首先从一个三级嵌套的列表节点复制出内容</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%80%E5%A7%8B%E5%8C%B9%E9%85%8D%E9%80%82%E5%90%88%E7%9A%84%E4%BD%8D%E7%BD%AE"><span class="toc-number">2.3.2.</span> <span class="toc-text">开始匹配适合的位置</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E6%80%BB%E7%BB%93"><span class="toc-number">3.</span> <span class="toc-text">三、总结</span></a></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index py4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        富文本编辑框架Prosemirror - 如何对state进行修改
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">lastnigtic</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2020-09-05T16:00:00.000Z" itemprop="datePublished">2020-09-06</time>
        
      
    </div>


      

      

    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <p>上一篇文章上讲到了prosemirror是如何把state的状态渲染到DOM视图的，这一篇文章来分析一下用户的编辑操作是怎么去修改state的。</p>
<h2 id="一、prosemirror-state"><a href="#一、prosemirror-state" class="headerlink" title="一、prosemirror-state"></a>一、<strong>prosemirror-state</strong></h2><p><code>prosemirror-state</code>是<code>propsemirror</code>用于描述整篇文档状态的数据结构，它主要包括以下几个属性；</p>
<h3 id="doc"><a href="#doc" class="headerlink" title="doc"></a><a target="_blank" rel="noopener" href="https://prosemirror.net/docs/ref/#state.EditorState.doc">doc</a></h3><p><code>doc</code>就是当前整篇文档的数据内容，<code>doc</code>是一个<a target="_blank" rel="noopener" href="https://prosemirror.net/docs/ref/#model.Node">Node</a>类型元素，<code>Node</code>可以理解为<code>prosemirror</code>文章树中的一个节点，代表着一个文档中的元素。<code>Node</code>包含一个<code>content</code>属性，代表它的子节点，是一个<a target="_blank" rel="noopener" href="https://prosemirror.net/docs/ref/#model.Fragment">Fragment</a>类型的元素，它代表着一个文档片段，可以理解为当前节点的所有子元素的一个集合。</p>
<p><code>prosemirror</code>通过<code>Node</code>以及<code>Fragment</code>类型完整地描述文档中数据内容。</p>
<h3 id="selection"><a href="#selection" class="headerlink" title="selection"></a><a target="_blank" rel="noopener" href="https://prosemirror.net/docs/ref/#state.Selection">selection</a></h3><p><code>selection</code>即当前文档中选取的信息，由于<code>contenteditable</code>对光标位置的处理不尽如人意，所以绝大多数的编辑器都会维护自己的选区信息，用于抹平浏览器原生处理带来的问题。<code>prosemirror</code>中提供了一个<code>Selection</code>基类，并在此基础上扩展出<a target="_blank" rel="noopener" href="https://prosemirror.net/docs/ref/#state.TextSelection">Textselection</a>，<a target="_blank" rel="noopener" href="https://prosemirror.net/docs/ref/#state.NodeSelection">NodeSelection</a>，<a target="_blank" rel="noopener" href="https://prosemirror.net/docs/ref/#state.AllSelection">AllSelection</a>这几种selection类型，也支持自行扩展出其他类型。</p>
<p>与浏览器自带的selection类似，prosemirror中的selection也存在anchor，head用于指示选区方向，标明选区在文档中的位置，并且提供了强大的<a target="_blank" rel="noopener" href="https://prosemirror.net/docs/ref/#model.ResolvedPos">ReslovePos</a>结构，可以获取当前选区位置在文档中的各种信息，包括位置，当前相对于上层元素的路径，相邻元素等等信息，可以方便地对文档内容做处理。</p>
<h3 id="tr-Transaction"><a href="#tr-Transaction" class="headerlink" title="tr(Transaction)"></a><a target="_blank" rel="noopener" href="https://prosemirror.net/docs/ref/#state.Transaction">tr(Transaction)</a></h3><p>Transaction继承自<a target="_blank" rel="noopener" href="https://prosemirror.net/docs/ref/#transform.Transform">Transform</a>，Transform代表着对文档的一系列操作，每个操作的原子为一个<a target="_blank" rel="noopener" href="https://prosemirror.net/docs/ref/#transform.Step">Step</a>，每个Step都提供了apply，invert，merge等方法（支撑prosemirror的协同编辑），step会保存当前操作的<a target="_blank" rel="noopener" href="https://prosemirror.net/docs/ref/#model.Slice">Slice</a>内容，生成新的doc并把旧的doc信息存储在tr.docs属性中，tr关注的doc内容本身，而不关心具体selection的位置。</p>
<h3 id="Schema"><a href="#Schema" class="headerlink" title="Schema"></a><a target="_blank" rel="noopener" href="https://prosemirror.net/docs/ref/#model.Document_Schema">Schema</a></h3><p>schema这种包含当前文档所支持的所有内容，分为node和mark，node即使元素类型，mark可以理解为是node的附加属性，更多是相当于一种标记，常用于标记加粗，斜体这类属性。</p>
<h2 id="二、State更新过程"><a href="#二、State更新过程" class="headerlink" title="二、State更新过程"></a>二、<strong>State更新过程</strong></h2><p>下面我们由用户按下一个按键的简单场景来了解<code>prosemirror</code>是如何对state进行更新的。</p>
<p>首先我们先了解一下<code>prosemirror</code>是如何监听事件的，这部分工作主要是在<code>prosemirror-view</code>中处理的，<code>prosemirror-view</code>是<code>prosemirror</code>中另外一个核心模块，主要负责处理着用户与编辑器交互行为，更新<code>state</code>以及<code>state</code>渲染到DOM。</p>
<ol>
<li><strong>英文输入</strong></li>
</ol>
<p>无差异</p>
<ol>
<li><strong>中文输入</strong></li>
</ol>
<ul>
<li><p><code>IE</code>，<code>Chrome</code>，<code>Safari</code>：触发<code>keydown， 不触发</code>keypress</p>
</li>
<li><p><code>Firefox</code>：</p>
<ul>
<li>首次按下时触发<code>keydown</code>，不触发<code>keypress</code></li>
<li>在停止输入并改变文本框内容(如按下回车或者空格键)后会触发<code>keyup</code>（<strong>只有在触发keyup事件才能获得修改后的文本值）</strong></li>
</ul>
</li>
<li><p><code>Opera</code>：<code>keydown, keypress和keyup</code>都不触发</p>
</li>
</ul>
<ol>
<li><strong>大小写</strong></li>
</ol>
<ul>
<li>大写：<code>keydown、keypress</code>(字母，主键盘数字、回车)、<code>keyup</code>的<code>which</code>值相等</li>
<li>小写：<code>kepress</code>获取的<code>which</code>不同于<code>keydown、keyup</code></li>
</ul>
<ol>
<li><strong>按住不放</strong></li>
</ol>
<ul>
<li>会一直触发<code>keydown</code>,只触发一次<code>keypress</code></li>
</ul>
<ol>
<li><strong>非字符</strong>键</li>
</ol>
<ul>
<li>会触发<code>keydown</code>，不会触发<code>keypress</code></li>
</ul>
<p>经过上面的分析，我们可以看到，使用<code>keypress</code>事件来作为输入监听是比较合适的，可以区分大小写，不会重复触发，且非字符键也不会触发。<code>prosemirror</code>中对于输入事件的处理也是通过的<code>keypress</code>的监听，<code>keydown</code>和<code>keyup</code>主要用于监听一些功能按键。</p>
<h3 id="输入英文"><a href="#输入英文" class="headerlink" title="输入英文"></a><strong>输入英文</strong></h3><p>首先看一下<code>prosemirror</code>中处理<code>keypress</code>的代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">editHandlers.keypress &#x3D; (view, event) &#x3D;&gt; &#123;</span><br><span class="line">  if (inOrNearComposition(view, event) || !event.charCode ||</span><br><span class="line">      event.ctrlKey &amp;&amp; !event.altKey || browser.mac &amp;&amp; event.metaKey) return</span><br><span class="line"></span><br><span class="line">  if (view.someProp(&quot;handleKeyPress&quot;, f &#x3D;&gt; f(view, event))) &#123;</span><br><span class="line">    event.preventDefault()</span><br><span class="line">    return</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  let sel &#x3D; view.state.selection</span><br><span class="line">  if (!(sel instanceof TextSelection) || !sel.$from.sameParent(sel.$to)) &#123;</span><br><span class="line">    let text &#x3D; String.fromCharCode(event.charCode)</span><br><span class="line">    if (!view.someProp(&quot;handleTextInput&quot;, f &#x3D;&gt; f(view, sel.$from.pos, sel.$to.pos, text)))</span><br><span class="line">      view.dispatch(view.state.tr.insertText(text).scrollIntoView())</span><br><span class="line">    event.preventDefault()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>prosemirror</code>中使用的的是<code>charCode</code>这个属性用于获取输入的内容，关于<code>charCode</code>的具体信息可以<a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/charCode">参阅这里</a>。</p>
<p><code>keypress</code>事件发生时，<code>prosemirror</code>会判断当前<code>selection</code>是否是<code>TextSelection</code>或者光标的起始和中止位置是否相同（为了判断选中了内容，选中了内容需要进行删除处理，后面会讲到）。简单的输入事件<code>prosemirror</code>进行一个<code>insertText</code>的操作去修改<code>state</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">insertText(text, from, to &#x3D; from) &#123;</span><br><span class="line">  let schema &#x3D; this.doc.type.schema</span><br><span class="line">  if (from &#x3D;&#x3D; null) &#123;</span><br><span class="line">    if (!text) return this.deleteSelection()</span><br><span class="line">    return this.replaceSelectionWith(schema.text(text), true)</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    if (!text) return this.deleteRange(from, to)</span><br><span class="line">    let marks &#x3D; this.storedMarks</span><br><span class="line">    if (!marks) &#123;</span><br><span class="line">      let $from &#x3D; this.doc.resolve(from)</span><br><span class="line">      marks &#x3D; to &#x3D;&#x3D; from ? $from.marks() : $from.marksAcross(this.doc.resolve(to))</span><br><span class="line">    &#125;</span><br><span class="line">    this.replaceRangeWith(from, to, schema.text(text, marks))</span><br><span class="line">    if (!this.selection.empty) this.setSelection(Selection.near(this.selection.$to))</span><br><span class="line">    return this</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>insertText</code>可以选择在当前位置插入或者选中位置插入，插入的逻辑就是替换当前选中的内容，还有一些处理就是继承插入位置的mark属性，插入后选区的位置处理等。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">replaceSelectionWith(node, inheritMarks) &#123;</span><br><span class="line">  let selection &#x3D; this.selection</span><br><span class="line">  if (inheritMarks !&#x3D;&#x3D; false)</span><br><span class="line">    node &#x3D; node.mark(this.storedMarks || (selection.empty ? selection.$from.marks() : (selection.$from.marksAcross(selection.$to) || Mark.none)))</span><br><span class="line">  selection.replaceWith(this, node)</span><br><span class="line">  return this</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; selection</span><br><span class="line">replaceWith(tr, node) &#123;</span><br><span class="line">    let mapFrom &#x3D; tr.steps.length, ranges &#x3D; this.ranges</span><br><span class="line">    for (let i &#x3D; 0; i &lt; ranges.length; i++) &#123;</span><br><span class="line">      let &#123;$from, $to&#125; &#x3D; ranges[i], mapping &#x3D; tr.mapping.slice(mapFrom)</span><br><span class="line">      let from &#x3D; mapping.map($from.pos), to &#x3D; mapping.map($to.pos)</span><br><span class="line">      if (i) &#123;</span><br><span class="line">        tr.deleteRange(from, to)</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        tr.replaceRangeWith(from, to, node)</span><br><span class="line">        selectionToInsertionEnd(tr, mapFrom, node.isInline ? -1 : 1)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; transfrom</span><br><span class="line">replaceRangeWith &#x3D; function(from, to, node) &#123;</span><br><span class="line">  if (!node.isInline &amp;&amp; from &#x3D;&#x3D; to &amp;&amp; this.doc.resolve(from).parent.content.size) &#123;</span><br><span class="line">    let point &#x3D; insertPoint(this.doc, from, node.type)</span><br><span class="line">    if (point !&#x3D; null) from &#x3D; to &#x3D; point</span><br><span class="line">  &#125;</span><br><span class="line">  return this.replaceRange(from, to, new Slice(Fragment.from(node), 0, 0))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到两个处理分支的最后都会流向<code>replaceRangeWith</code>这个方法，不同在于一个需要删除当前选区位置内容，一个要删除指定位置的内容而已。下面我们具体分析一下<code>repaceRange</code>这个方法做了什么事情。</p>
<p>首先我们先理解一下什么是<a target="_blank" rel="noopener" href="https://prosemirror.net/docs/ref/#model.Slice">Slice</a>，slice是文档的一个切片，代表文档的一个片段，保存着文档的片段信息以及节点嵌套的深度信息。</p>
<p>下面我们再进入<code>replaceRange</code>方法，看下做了什么处理</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; model</span><br><span class="line">&#x2F;&#x2F; 根据schema定义判断是否可以替换到当前节点</span><br><span class="line">canReplaceWith(from, to, type, marks) &#123;</span><br><span class="line">  if (marks &amp;&amp; !this.type.allowsMarks(marks)) return false</span><br><span class="line">  let start &#x3D; this.contentMatchAt(from).matchType(type)</span><br><span class="line">  let end &#x3D; start &amp;&amp; start.matchFragment(this.content, to)</span><br><span class="line">  return end ? end.validEnd : false</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; transform</span><br><span class="line">replaceRange &#x3D; function(from, to, slice) &#123;</span><br><span class="line">  let preferredDepth, leftNodes, targetDepths;</span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F; 寻找适合插入的深度</span><br><span class="line"></span><br><span class="line">  for (let j &#x3D; slice.openStart; j &gt;&#x3D; 0; j--) &#123;</span><br><span class="line">    &#x2F;&#x2F;        ...</span><br><span class="line">    &#x2F;&#x2F; 匹配到适合插入的位置</span><br><span class="line">    if (parent.canReplaceWith(index, index, insert.type, insert.marks))</span><br><span class="line">      return this.replace($from.before(targetDepth), expand ? $to.after(targetDepth) : to,</span><br><span class="line">                          new Slice(closeFragment(slice.content, 0, slice.openStart, openDepth),</span><br><span class="line">                                    openDepth, slice.openEnd))</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 如果未匹配到合适的插入点，直接进入replace</span><br><span class="line">    let startSteps &#x3D; this.steps.length</span><br><span class="line">    for (let i &#x3D; targetDepths.length - 1; i &gt;&#x3D; 0; i--) &#123;</span><br><span class="line">      this.replace(from, to, slice)</span><br><span class="line">      if (this.steps.length &gt; startSteps) break</span><br><span class="line">      let depth &#x3D; targetDepths[i]</span><br><span class="line">      if (i &lt; 0) continue</span><br><span class="line">      from &#x3D; $from.before(depth); to &#x3D; $to.after(depth)</span><br><span class="line">    &#125;</span><br><span class="line">    return this</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到<code>replaceRange</code>的主要工作就是找到到适合插入的位置，进行插入操作。下面看看<code>replace</code>做了什么:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; transform  </span><br><span class="line">function fitsTrivially($from, $to, slice) &#123;</span><br><span class="line">  return !slice.openStart &amp;&amp; !slice.openEnd &amp;&amp; $from.start() &#x3D;&#x3D; $to.start() &amp;&amp;</span><br><span class="line">    $from.parent.canReplace($from.index(), $to.index(), slice.content)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">replace &#x3D; function(from, to &#x3D; from, slice &#x3D; Slice.empty) &#123;</span><br><span class="line">  let step &#x3D; replaceStep(this.doc, from, to, slice)</span><br><span class="line">  if (step) this.step(step)</span><br><span class="line">  return this</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">replaceStep &#x3D; function(doc, from, to &#x3D; from, slice &#x3D; Slice.empty) &#123;</span><br><span class="line">  if (from &#x3D;&#x3D; to &amp;&amp; !slice.size) return null</span><br><span class="line"></span><br><span class="line">  let $from &#x3D; doc.resolve(from), $to &#x3D; doc.resolve(to)</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 在第一层简单插入</span><br><span class="line">  if (fitsTrivially($from, $to, slice)) return new ReplaceStep(from, to, slice)</span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">export class ReplaceStep extends Step &#123;</span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line"></span><br><span class="line">  apply(doc) &#123;</span><br><span class="line">    if (this.structure &amp;&amp; contentBetween(doc, this.from, this.to))</span><br><span class="line">      return StepResult.fail(&quot;Structure replace would overwrite content&quot;)</span><br><span class="line">    return StepResult.fromReplace(doc, this.from, this.to, this.slice)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class StepResult &#123;</span><br><span class="line"> </span><br><span class="line">         static ok(doc) &#123; return new StepResult(doc, null) &#125;</span><br><span class="line"></span><br><span class="line">        fromReplace(doc, from, to, slice) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      return StepResult.ok(doc.replace(from, to, slice))</span><br><span class="line">    &#125; catch (e) &#123;</span><br><span class="line">      if (e instanceof ReplaceError) return StepResult.fail(e.message)</span><br><span class="line">      throw e</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>replace</code>创建了一个<code>step</code>去修改<code>doc</code>的内容。在<code>prosemirror</code>中，所有对文档的修改都是由<code>Step</code>去实现的，在<code>Step.apply</code>中调用了<code>Node.replace</code>的方法，下面我们看一下<code>Node.replace</code>具体做了什么：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; model</span><br><span class="line">function close(node, content) &#123;</span><br><span class="line">  if (!node.type.validContent(content))</span><br><span class="line">    throw new ReplaceError(&quot;Invalid content for node &quot; + node.type.name)</span><br><span class="line">  return node.copy(content)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export function replace($from, $to, slice) &#123;</span><br><span class="line">  if (slice.openStart &gt; $from.depth)</span><br><span class="line">    throw new ReplaceError(&quot;Inserted content deeper than insertion position&quot;)</span><br><span class="line">  if ($from.depth - slice.openStart !&#x3D; $to.depth - slice.openEnd)</span><br><span class="line">    throw new ReplaceError(&quot;Inconsistent open depths&quot;)</span><br><span class="line">  return replaceOuter($from, $to, slice, 0)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function replaceOuter($from, $to, slice, depth) &#123;</span><br><span class="line">  let index &#x3D; $from.index(depth), node &#x3D; $from.node(depth)</span><br><span class="line">  if (index &#x3D;&#x3D; $to.index(depth) &amp;&amp; depth &lt; $from.depth - slice.openStart) &#123;</span><br><span class="line">    let inner &#x3D; replaceOuter($from, $to, slice, depth + 1)</span><br><span class="line">    return node.copy(node.content.replaceChild(index, inner))</span><br><span class="line">  &#125; else if (!slice.content.size) &#123;</span><br><span class="line">    return close(node, replaceTwoWay($from, $to, depth))</span><br><span class="line">  &#125; else if (!slice.openStart &amp;&amp; !slice.openEnd &amp;&amp; $from.depth &#x3D;&#x3D; depth &amp;&amp; $to.depth &#x3D;&#x3D; depth) &#123;</span><br><span class="line">    &#x2F;&#x2F; Simple, flat case</span><br><span class="line">    let parent &#x3D; $from.parent, content &#x3D; parent.content</span><br><span class="line">    return close(parent, content.cut(0, $from.parentOffset).append(slice.content).append(content.cut($to.parentOffset)))</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    let &#123;start, end&#125; &#x3D; prepareSliceForReplace(slice, $from)</span><br><span class="line">    return close(node, replaceThreeWay($from, start, end, $to, depth))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先不管什么其他具体的replace操作的逻辑，实际上的操作都是对<code>Node</code>的操作， 通过<code>cut</code>，<code>replace</code>，<code>slice</code>等方法构造出一个新的节点。可以看到了<code>close</code>返回的一个新的节点，这个节点的<code>content</code>是复用旧的数据。这样prosemirror就实现了一个简单的immutable结构，既可以保存修改前的文档，又不会占用过多的内存。</p>
<h3 id="输入中文"><a href="#输入中文" class="headerlink" title="输入中文"></a>输入中文</h3><p>对于中文的输入，由上文可以知道，各个浏览器的实现不一致，<code>prosemirror</code>判断到当前在<code>composition</code>事件时，并不做具体处理，而是使用<code>MutationObserver</code>，监听到到DOM的变化，具体的判断比较复杂，这里不做详细说明，但最后还是会转换成对<code>state</code>的修改。</p>
<p>上面的流程可以简单归结为 拿到插入的内容 -&gt; 寻找适合插入的位置 -&gt; 返回新的文档。这里面主要的难点是在寻找适合的插入位置这一步，由于简单的输入<code>depth</code>都是0，下面详细剖析若<code>depth</code>非零状态下，如何寻找适合的插入位置。</p>
<h3 id="如何寻找插入位置"><a href="#如何寻找插入位置" class="headerlink" title="如何寻找插入位置"></a><strong>如何寻找插入位置</strong></h3><p>这一步从复制粘贴内容出发，看在<code>prosemirror</code>中如何寻找到合适的插入位置的。</p>
<ol>
<li><h4 id="首先从一个三级嵌套的列表节点复制出内容"><a href="#首先从一个三级嵌套的列表节点复制出内容" class="headerlink" title="首先从一个三级嵌套的列表节点复制出内容"></a>首先从一个三级嵌套的列表节点复制出内容</h4></li>
</ol>
<p><img src="/.cn//list-dom.png" alt="img"></p>
<p>此时切出来的片段内<code>content</code>为一个<code>Fragment</code>，<code>openStart</code>和<code>openEnd</code>指的是当前切片的深度，可以看到嵌套了三个<code>ol</code>以及一个<code>li</code>，所以值为4；<code>size</code>为1，指的是实际复制的切片内容大小为1，但<code>content</code>的内容有9的大小，是因为<code>slice</code>同时包含了复制内内容到顶层节点的路径内容。</p>
<p><img src="/.cn//slice.png" alt="img"></p>
<ol>
<li><h4 id="开始匹配适合的位置"><a href="#开始匹配适合的位置" class="headerlink" title="开始匹配适合的位置"></a>开始匹配适合的位置</h4></li>
</ol>
<p>此时我们在文档的直接子节点内执行粘贴操作：</p>
<p><img src="/.cn//target-depths.png" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">  &#x2F;&#x2F; 此时的操作是直接在文档直接下级元素上粘贴，所以$from和$to的depth都为1 </span><br><span class="line">  let targetDepths &#x3D; coveredDepths($from, this.doc.resolve(to)); </span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function coveredDepths($from, $to) &#123;</span><br><span class="line">  let result &#x3D; [], minDepth &#x3D; Math.min($from.depth, $to.depth)</span><br><span class="line">  for (let d &#x3D; minDepth; d &gt;&#x3D; 0; d--) &#123;</span><br><span class="line">    &#x2F;&#x2F; start是找到指定深度节点的内容起始的位置，end则是结束位置</span><br><span class="line">    let start &#x3D; $from.start(d)</span><br><span class="line">    if (start &lt; $from.pos - ($from.depth - d) ||</span><br><span class="line">        $to.end(d) &gt; $to.pos + ($to.depth - d) ||</span><br><span class="line">        $from.node(d).type.spec.isolating ||</span><br><span class="line">        $to.node(d).type.spec.isolating) break</span><br><span class="line">    &#x2F;&#x2F; 如果$from和$to属于同一个节点，储存起来</span><br><span class="line">    if (start &#x3D;&#x3D; $to.start(d)) result.push(d)</span><br><span class="line">  &#125;</span><br><span class="line">  return result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先拿到拿到当前的路径的深度信息，然后开始匹配适合的插入节点：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">let preferredTarget &#x3D; -($from.depth + 1);</span><br><span class="line">targetDepths.unshift(preferredTarget); &#x2F;&#x2F; targetDepths: [-2, 1]</span><br><span class="line"></span><br><span class="line">for (let d &#x3D; $from.depth, pos &#x3D; $from.pos - 1; d &gt; 0; d--, pos--) &#123;</span><br><span class="line">  &#x2F;&#x2F; 寻找非关键节点，且深度存在，设为默认插入深度</span><br><span class="line">  let spec &#x3D; $from.node(d).type.spec</span><br><span class="line">  if (spec.defining || spec.isolating) break</span><br><span class="line">  if (targetDepths.indexOf(d) &gt; -1) preferredTarget &#x3D; d</span><br><span class="line">  &#x2F;&#x2F; 如果当前插入位置在节点前，则在首位插入当前深度</span><br><span class="line">  else if ($from.before(d) &#x3D;&#x3D; pos) targetDepths.splice(1, 0, -d)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let preferredTargetIndex &#x3D; targetDepths.indexOf(preferredTarget) &#x2F;&#x2F; preferredTargetIndex: 1</span><br></pre></td></tr></table></figure>

<p>到这一步找到了默认的插入深度，根据我们的场景，此时找到的<code>preferredTarget === 1</code>，下一步</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">let leftNodes &#x3D; [], preferredDepth &#x3D; slice.openStart &#x2F;&#x2F; preferredDepth: 4</span><br><span class="line">&#x2F;&#x2F; 把当前slice的节点收集起来</span><br><span class="line">for (let content &#x3D; slice.content, i &#x3D; 0;; i++) &#123;</span><br><span class="line">  &#x2F;&#x2F; 只收集firstChild是因为只需要关心第一个节点能不插入</span><br><span class="line">  &#x2F;&#x2F; 其余节点能不能插入是在node.replace中去判断的</span><br><span class="line">  let node &#x3D; content.firstChild</span><br><span class="line">  leftNodes.push(node)</span><br><span class="line">  if (i &#x3D;&#x3D; slice.openStart) break</span><br><span class="line">  content &#x3D; node.content</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; leftNodes: [ol, ol, ol, li, text]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 这一步开始寻找适合插入深度，跳过关键节点，</span><br><span class="line">if (preferredDepth &gt; 0 &amp;&amp; leftNodes[preferredDepth - 1].type.spec.defining &amp;&amp; </span><br><span class="line">    $from.node(preferredTargetIndex).type !&#x3D; leftNodes[preferredDepth - 1].type) &#123;</span><br><span class="line">  preferredDepth -&#x3D; 1</span><br><span class="line">&#125; else if (preferredDepth &gt;&#x3D; 2 &amp;&amp; leftNodes[preferredDepth - 1].isTextblock &amp;&amp; leftNodes[preferredDepth - 2].type.spec.defining &amp;&amp; $from.node(preferredTargetIndex).type !&#x3D; leftNodes[preferredDepth - 2].type) &#123;</span><br><span class="line">  preferredDepth -&#x3D; 2</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; preferreDepth: 2</span><br></pre></td></tr></table></figure>

<p>到这步跳过了关键节点，找到了默认插入深度，之后就是看看具体的节点是否能接受内容作为子节点，否则就往上寻找</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;  targetDepths: [-2, 1]，preferreDepth: 2， preferredTargetIndex: 1</span><br><span class="line">for (let j &#x3D; slice.openStart; j &gt;&#x3D; 0; j--) &#123;</span><br><span class="line">  let openDepth &#x3D; (j + preferredDepth + 1) % (slice.openStart + 1)</span><br><span class="line">  let insert &#x3D; leftNodes[openDepth]</span><br><span class="line">  if (!insert) continue</span><br><span class="line">  for (let i &#x3D; 0; i &lt; targetDepths.length; i++) &#123;</span><br><span class="line">    &#x2F;&#x2F; 从上面找到的默认深度开始，需要适合的节点</span><br><span class="line">    let targetDepth &#x3D; targetDepths[(i + preferredTargetIndex) % targetDepths.length]</span><br><span class="line">    let expand &#x3D; true</span><br><span class="line">    if (targetDepth &lt; 0) &#123; expand &#x3D; false; targetDepth &#x3D; -targetDepth &#125;</span><br><span class="line">    let parent &#x3D; $from.node(targetDepth - 1) &#x2F;&#x2F; 当前深度的上级元素</span><br><span class="line">    let index &#x3D; $from.index(targetDepth - 1) &#x2F;&#x2F; 当前深度的元素在父元素中的索引，即在parent中索引</span><br><span class="line">    if (parent.canReplaceWith(index, index, insert.type, insert.marks)) &#123;</span><br><span class="line">      return this.replace($from.before(targetDepth), expand ? $to.after(targetDepth) : to,</span><br><span class="line">                          new Slice(closeFragment(slice.content, 0, slice.openStart, openDepth),</span><br><span class="line">                                    openDepth, slice.openEnd))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到这一步，就完成了插入位置寻找，剩下的工作就是节点内容的替换，在上文已经了解过。</p>
<h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><p><code>prosemirror</code>通过维护自己的文档数据树，并把所有对dom的操作都转换成对<code>state</code>的操作，抹平了不同浏览器带来的数据结构不一致的问题，并提升了<code>prosemirror</code>本身的视图层的可移植性，理论上可以通过自身实现视图层在任何平台上都实现编辑器。维护自身文档数据结构也可以说是一个比较主流解决方案，因为它让内容可控，状态可以变，并且为实现协同编辑提供了结构上的支撑。</p>

  </div>
</article>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/archives/">Writing</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81prosemirror-state"><span class="toc-number">1.</span> <span class="toc-text">一、prosemirror-state</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#doc"><span class="toc-number">1.1.</span> <span class="toc-text">doc</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#selection"><span class="toc-number">1.2.</span> <span class="toc-text">selection</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tr-Transaction"><span class="toc-number">1.3.</span> <span class="toc-text">tr(Transaction)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Schema"><span class="toc-number">1.4.</span> <span class="toc-text">Schema</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81State%E6%9B%B4%E6%96%B0%E8%BF%87%E7%A8%8B"><span class="toc-number">2.</span> <span class="toc-text">二、State更新过程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E8%8B%B1%E6%96%87"><span class="toc-number">2.1.</span> <span class="toc-text">输入英文</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E4%B8%AD%E6%96%87"><span class="toc-number">2.2.</span> <span class="toc-text">输入中文</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AF%BB%E6%89%BE%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE"><span class="toc-number">2.3.</span> <span class="toc-text">如何寻找插入位置</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A6%96%E5%85%88%E4%BB%8E%E4%B8%80%E4%B8%AA%E4%B8%89%E7%BA%A7%E5%B5%8C%E5%A5%97%E7%9A%84%E5%88%97%E8%A1%A8%E8%8A%82%E7%82%B9%E5%A4%8D%E5%88%B6%E5%87%BA%E5%86%85%E5%AE%B9"><span class="toc-number">2.3.1.</span> <span class="toc-text">首先从一个三级嵌套的列表节点复制出内容</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%80%E5%A7%8B%E5%8C%B9%E9%85%8D%E9%80%82%E5%90%88%E7%9A%84%E4%BD%8D%E7%BD%AE"><span class="toc-number">2.3.2.</span> <span class="toc-text">开始匹配适合的位置</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E6%80%BB%E7%BB%93"><span class="toc-number">3.</span> <span class="toc-text">三、总结</span></a></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=http://lastnigtic.cn/prosemirror-state-modify/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=http://lastnigtic.cn/prosemirror-state-modify/&text=富文本编辑框架Prosemirror - 如何对state进行修改"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=http://lastnigtic.cn/prosemirror-state-modify/&title=富文本编辑框架Prosemirror - 如何对state进行修改"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=http://lastnigtic.cn/prosemirror-state-modify/&is_video=false&description=富文本编辑框架Prosemirror - 如何对state进行修改"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=富文本编辑框架Prosemirror - 如何对state进行修改&body=Check out this article: http://lastnigtic.cn/prosemirror-state-modify/"><i class="fas fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=http://lastnigtic.cn/prosemirror-state-modify/&title=富文本编辑框架Prosemirror - 如何对state进行修改"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=http://lastnigtic.cn/prosemirror-state-modify/&title=富文本编辑框架Prosemirror - 如何对state进行修改"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=http://lastnigtic.cn/prosemirror-state-modify/&title=富文本编辑框架Prosemirror - 如何对state进行修改"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=http://lastnigtic.cn/prosemirror-state-modify/&title=富文本编辑框架Prosemirror - 如何对state进行修改"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=http://lastnigtic.cn/prosemirror-state-modify/&name=富文本编辑框架Prosemirror - 如何对state进行修改&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=http://lastnigtic.cn/prosemirror-state-modify/&t=富文本编辑框架Prosemirror - 如何对state进行修改"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fas fa-bars fa-lg" aria-hidden="true"></i> Menu</a>
        <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fas fa-list fa-lg" aria-hidden="true"></i> TOC</a>
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fas fa-share-alt fa-lg" aria-hidden="true"></i> Share</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2017-2021
    lastnigtic
  </div>
  <div class="footer-right">
    <nav>
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/archives/">Writing</a></li>
        
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->



  <link rel="preload" as="style" href="https://cdn.staticfile.org/font-awesome/5.15.3/css/all.min.css" crossorigin="anonymous" onload="this.onload=null;this.rel='stylesheet'"/>


    <!-- jquery -->
 
  <script src="https://cdn.bootcdn.net/ajax/libs/jquery/3.6.0/jquery.slim.min.js" crossorigin="anonymous"></script> 




<!-- clipboard -->

  
    <script src="https://cdn.bootcdn.net/ajax/libs/clipboard.js/2.0.8/clipboard.min.js" crossorigin="anonymous"></script> 
  
  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"Copy to clipboard!\">";
    btn += '<i class="far fa-clone"></i>';
    btn += '</span>'; 
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "Copied!");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Google Analytics -->

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Umami Analytics -->

<!-- Disqus Comments -->


</body>
</html>
